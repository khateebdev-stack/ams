// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                   String   @id @default(uuid())
  username             String   @unique
  // Public salt for KDF
  salt                 String
  // Authentication hash (derived from MasterKey, not the password itself)
  authHash             String
  // The encrypted VaultKey (wrapped with MasterKey)
  encryptedVaultKey    String
  // The VaultKey encrypted with the Recovery Key
  encryptedRecoveryKey String?
  
  // WebAuthn state
  currentChallenge     String?

  // Account Recovery
  recoverySalt         String?
  recoveryVaultKey     String?

  // Two-Factor Authentication
  twoFactorEnabled     Boolean  @default(false)
  twoFactorSecret      String?
  tempTwoFactorSecret  String?
  
  createdAt            DateTime @default(now())
  
  vaults               Vault[]
  accounts             AccountEntry[]
  sessions             Session[]
  auditLogs            AuditLog[]
  passkeys             Passkey[]
  trustTokens          TrustToken[]
}

model Session {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash String   @unique // Hash of the session token
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  // Threat-Aware State
  threatLevel Int     @default(0)
  isLockedDown Boolean @default(false)
}

model Vault {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name            String
  icon            String   @default("Lock") // Lucide icon name
  
  // The sub-vault key wrapped by the user's Master Vault Key
  encryptedSubKey String
  iv              String   // Nonce for the sub-key encryption
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  entries         AccountEntry[]
}

model AccountEntry {
  id             String   @id @default(uuid())
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  vaultId        String?
  vault          Vault?   @relation(fields: [vaultId], references: [id], onDelete: Cascade)
  
  // The core encrypted blob (JSON string encrypted with the Sub-Vault Key)
  encryptedData  String
  iv             String
  
  blindIndex     String?

  lastAccessedAt DateTime @default(now())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  // Security Flag
  isHoneyToken   Boolean  @default(false)
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  username  String?
  event     String   
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
}

model Passkey {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  credentialId String   @unique
  publicKey    String   
  counter      Int      @default(0)
  deviceType   String   
  backedUp     Boolean  @default(false)
  transports   String?  
  
  wrappedKey   String?
  
  createdAt    DateTime @default(now())
}

model TrustToken {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  fingerprintHash String
  token           String?
  deviceName      String?
  expiresAt       DateTime?
  createdAt       DateTime @default(now())
  
  @@unique([userId, fingerprintHash])
}
